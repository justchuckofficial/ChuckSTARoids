# Complete Spinout Methods from chuckstaroidsv4.py
# This file contains all spinout-related classes and methods

import pygame
import math
import random

# SpinoutParticle Class - Dedicated particle class for spinout sparks
class SpinoutParticle:
    """Dedicated particle class for spinout sparks with specific properties"""
    def __init__(self, x, y, vx, vy, color, lifetime=0.8, size=2.5, spark_type="firey"):
        self.x = x
        self.y = y
        self.vx = vx
        self.vy = vy
        self.color = color
        self.lifetime = lifetime
        self.max_lifetime = lifetime
        self.size = size
        self.spark_type = spark_type  # "firey" or "electric"
        self.active = True
        self.flicker_timer = 0.0  # For electric spark flickering
        self.initial_velocity = math.sqrt(vx*vx + vy*vy)  # Store initial speed for physics
        self.use_raw_time = False  # SpinoutParticles use normal time dilation
    
    def update(self, dt, screen_width=None, screen_height=None):
        if not self.active:
            return
            
        # Apply physics - sparks slow down over time
        self.vx *= 0.98  # Gradual deceleration
        self.vy *= 0.98
        
        self.x += self.vx * dt
        self.y += self.vy * dt
        self.lifetime -= dt
        
        # Electric sparks flicker
        if self.spark_type == "electric":
            self.flicker_timer += dt * 20.0  # Fast flicker
        
        # Screen wrapping for particles
        if screen_width is not None and screen_height is not None:
            if self.x < 0:
                self.x = screen_width
            elif self.x > screen_width:
                self.x = 0
            if self.y < 0:
                self.y = screen_height
            elif self.y > screen_height:
                self.y = 0
        
        # Fade out over time
        self.lifetime = max(0, self.lifetime)
        
        if self.lifetime <= 0:
            self.active = False
    
    def draw(self, screen):
        if not self.active:
            return
            
        # Calculate alpha based on remaining lifetime
        alpha = int(255 * (self.lifetime / self.max_lifetime))
        alpha = max(0, min(255, alpha))
        
        # Electric sparks flicker
        if self.spark_type == "electric":
            flicker = 0.7 + 0.3 * math.sin(self.flicker_timer)
            alpha = int(alpha * flicker)
        
        # Create color with alpha
        color_with_alpha = (*self.color, alpha)
        
        # Draw particle with spark-specific rendering
        radius = max(1, int(self.size))
        
        if self.spark_type == "electric":
            # Electric sparks are brighter and more intense
            pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), radius)
            # Add a bright center for electric sparks
            if radius > 1:
                pygame.draw.circle(screen, (255, 255, 255), (int(self.x), int(self.y)), max(1, radius-1))
        else:
            # Firey sparks
            pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), radius)


# Spinout Methods for AdvancedUFO Class

def trigger_spinout(self):
    """Trigger the spinout 'Burst into Flames' effect"""
    try:
        # Ensure rotation_speed exists
        if not hasattr(self, 'rotation_speed'):
            self.rotation_speed = 2.0
        
        self.spinout_active = True
        self.spinout_timer = 0.0
        self.spinout_duration = 3.0  # 3 seconds duration
        self.spinout_flame_scale = 0.0
        self.spinout_flame_scale_timer = 0.0
        self.spinout_flame_scale_duration = random.uniform(1.0, 3.0)  # Random 1-3 seconds to scale up
        self.spinout_spark_timer = 0.0
        self.spinout_spark_interval = 1.0 / random.uniform(20, 42)  # 20-42 sparks per second
        self.spinout_collision_delay_timer = 0.0
        self.spinout_collision_delay = random.uniform(0.5, 1.5)  # Random delay 0.5-1.5 seconds before explosion
        
        # Set movement type - 80% straight, 20% spiral for variety
        if random.random() < 0.8:
            self.spinout_movement_type = "straight"
        else:
            self.spinout_movement_type = "spiral"
        
        # Set rotation speed multiplier (1x to 10x)
        self.spinout_rotation_speed_multiplier = random.uniform(1.0, 10.0)
        self.spinout_target_rotation_speed = self.rotation_speed * self.spinout_rotation_speed_multiplier
        
        # Initialize visual rotation angle for spinout flame
        self.visual_rotation_angle = 0.0
        
        # Set up movement
        # Random speed multiplier between 3x and 5x
        self.spinout_speed_multiplier = random.uniform(3.0, 5.0)
        
        if self.spinout_movement_type == "straight":
            # Random direction with random velocity 100-250
            angle = random.uniform(0, 2 * math.pi)
            random_speed = random.uniform(100, 250)
            self.velocity = Vector2D(math.cos(angle), math.sin(angle)) * random_speed
        else:
            # Spiral outward - set up spiral parameters at fixed 250 speed
            self.spinout_spiral_center = Vector2D(self.position.x, self.position.y)
            self.spinout_spiral_angle = 0.0
            self.spinout_spiral_radius = 0.0
            # Start with current velocity direction for spiral at 250 units/second
            current_angle = math.atan2(self.velocity.y, self.velocity.x)
            self.velocity = Vector2D(math.cos(current_angle), math.sin(current_angle)) * 250
        
        # Velocity is now set directly above based on movement type
        
    except Exception as e:
        # Don't raise the exception, just set a default rotation speed and continue
        if not hasattr(self, 'rotation_speed'):
            self.rotation_speed = 2.0


def update_spinout(self, dt, explosion_system, game_instance=None):
    """Update spinout effect"""
    try:
        if not self.spinout_active:
            return
        
        # Apply time dilation to spinout timers
        time_dilation_factor = 1.0
        if game_instance and hasattr(game_instance, 'time_dilation_factor'):
            time_dilation_factor = game_instance.time_dilation_factor
        
        self.spinout_timer += dt * time_dilation_factor
        self.spinout_collision_delay_timer += dt * time_dilation_factor
    
        # Update flame scaling (0% to 100% over random 1-3 seconds)
        self.spinout_flame_scale_timer += dt * time_dilation_factor
        if self.spinout_flame_scale_timer < self.spinout_flame_scale_duration:
            self.spinout_flame_scale = self.spinout_flame_scale_timer / self.spinout_flame_scale_duration
        else:
            self.spinout_flame_scale = 1.0
        
        # Update movement
        if self.spinout_movement_type == "spiral":
            # Large expanding spiral movement at 250 units/second
            self.spinout_spiral_angle += dt * 2.0  # Spiral rotation speed
            self.spinout_spiral_radius += dt * 250  # Spiral expansion rate (250 units/second)
            
            # Ensure minimum radius of 50px
            if self.spinout_spiral_radius < 50:
                self.spinout_spiral_radius = 50
            
            # Logarithmic spiral: r = a * e^(b * Î¸)
            a = 50  # Minimum radius (50px)
            b = 0.05  # Growth rate for smooth expansion
            r = max(a, self.spinout_spiral_radius)
            
            # Convert to cartesian
            x = self.spinout_spiral_center.x + r * math.cos(self.spinout_spiral_angle)
            y = self.spinout_spiral_center.y + r * math.sin(self.spinout_spiral_angle)
            
            # Update velocity to move towards spiral position at 250 units/second
            target_pos = Vector2D(x, y)
            direction = target_pos - self.position
            if direction.magnitude() > 0:
                direction = direction.normalize()
                self.velocity = direction * 250  # Fixed 250 units/second for spiral
        
        # Update rotation speed gradually from 1x to target (1x-10x)
        current_rotation_speed = self.rotation_speed
        target_rotation_speed = self.spinout_target_rotation_speed
        if current_rotation_speed < target_rotation_speed:
            self.rotation_speed = min(target_rotation_speed, current_rotation_speed + dt * 5.0)
        
        # Update visual rotation angle for spinout flame (separate from movement angle)
        self.visual_rotation_angle += self.rotation_speed * dt * time_dilation_factor
        
        # Update UFO's angle to match current movement direction during spinout
        if self.velocity.magnitude() > 0:
            self.angle = math.atan2(self.velocity.y, self.velocity.x)
        
        # Debug logging for UFO spinout state
        
        # Generate sparks
        self.spinout_spark_timer += dt * time_dilation_factor
        if self.spinout_spark_timer >= self.spinout_spark_interval:
            self.spinout_spark_timer = 0.0
            self.spinout_spark_interval = 1.0 / random.uniform(20, 42)  # New random interval
            
            # Generate 1-20 sparks per burst
            num_sparks = random.randint(1, 20)
            for _ in range(num_sparks):
                # 66% firey, 34% electric
                if random.random() < 0.66:
                    # Firey colors (red/orange/yellow)
                    colors = [(255, 100, 0), (255, 150, 0), (255, 200, 0), (255, 50, 0)]
                    color = random.choice(colors)
                    spark_type = "firey"
                else:
                    # Electric colors (blue/white)
                    colors = [(0, 150, 255), (100, 200, 255), (255, 255, 255), (0, 100, 255)]
                    color = random.choice(colors)
                    spark_type = "electric"
                
                # Add dedicated spinout spark particle
                explosion_system.add_spinout_spark(
                    self.position.x,
                    self.position.y,
                    color,
                    spark_type
                )
        
        # Check if spinout duration is over (5 seconds)
        if self.spinout_timer >= self.spinout_duration:
            self.spinout_active = False
            self.active = False  # UFO dies after 5 seconds
            
            # Add final explosion and score when spinout ends
            # Generate 90 electric sparks for final explosion
            for _ in range(90):
                explosion_system.add_spinout_spark(
                    self.position.x,
                    self.position.y,
                    (0, 150, 255),  # Electric blue
                    "electric"
                )
            
            # Generate 10 bright white sparks
            for _ in range(10):
                explosion_system.add_spinout_spark(
                    self.position.x,
                    self.position.y,
                    (255, 255, 255),  # Bright white
                    "electric"
                )
            
            # Add score for UFO destruction
            if game_instance:
                game_instance.add_score(200)
    
    except Exception as e:
        # Disable spinout to prevent further crashes
        self.spinout_active = False


def draw_spinout(self, screen, shake_x=0, shake_y=0):
    """Draw spinout flame effect"""
    try:
        if not self.spinout_active or not self.spinout_flame_image:
            return
        
        # Scale the flame image based on current scale
        if self.spinout_flame_scale > 0:
            # Create scaled version
            original_size = self.spinout_flame_image.get_size()
            scaled_size = (
                int(original_size[0] * self.spinout_flame_scale),
                int(original_size[1] * self.spinout_flame_scale)
            )
            
            if scaled_size[0] > 0 and scaled_size[1] > 0:
                scaled_flame = pygame.transform.smoothscale(self.spinout_flame_image, scaled_size)
                # Rotate the flame to be parallel to UFO's movement direction (180 degrees behind)
                rotated_flame = pygame.transform.rotate(scaled_flame, -math.degrees(self.angle) + 180)
                # Apply screen shake offset to flame position to match UFO
                flame_x = int(self.position.x + shake_x)
                flame_y = int(self.position.y + shake_y)
                flame_rect = rotated_flame.get_rect(center=(flame_x, flame_y))
                screen.blit(rotated_flame, flame_rect)
    
    except Exception as e:
        # Disable spinout to prevent further crashes
        self.spinout_active = False


# ExplosionSystem Method for Spinout Sparks

def add_spinout_spark(self, x, y, color, spark_type="firey"):
    """Add a dedicated spinout spark particle with specific properties"""
    # High priority for spinout sparks
    priority = 4
    
    # Check particle limit before adding
    if not self._check_particle_limit(priority):
        return
    
    # Random velocity and direction for sparks
    angle = random.uniform(0, 2 * math.pi)
    speed = random.uniform(50, 200)
    vx = math.cos(angle) * speed
    vy = math.sin(angle) * speed
    
    # Random size based on spark type
    if spark_type == "electric":
        size = random.uniform(1.5, 3.5)
        lifetime = random.uniform(0.6, 1.2)  # Electric sparks last longer
    else:  # firey
        size = random.uniform(1.0, 3.0)
        lifetime = random.uniform(0.4, 0.8)  # Firey sparks burn out faster
    
    # Add small random offset to position
    spark_x = x + random.uniform(-10, 10)
    spark_y = y + random.uniform(-10, 10)
    
    # Create spinout particle with specific properties
    spinout_particle = SpinoutParticle(spark_x, spark_y, vx, vy, color, lifetime, size, spark_type)
    self.particles.append(spinout_particle)
    self.particle_priorities.append(priority)


# Spinout Properties (to be added to AdvancedUFO class __init__ method)
"""
# Spinout "Burst into Flames" effect properties
self.spinout_active = False
self.spinout_timer = 0.0
self.spinout_duration = 3.0  # 3 seconds duration
self.spinout_flame_scale = 0.0  # 0% to 100% scaling over random 1-3 seconds
self.spinout_flame_scale_timer = 0.0
self.spinout_flame_scale_duration = random.uniform(1.0, 3.0)  # Random 1-3 seconds to scale up
self.spinout_spark_timer = 0.0
self.spinout_spark_interval = 1.0 / random.uniform(20, 42)  # 20-42 sparks per second
self.spinout_movement_type = None  # "straight" or "spiral"
self.spinout_spiral_angle = 0.0
self.spinout_spiral_radius = 0.0
self.spinout_spiral_center = Vector2D(0, 0)
self.spinout_rotation_speed_multiplier = 1.0  # Will be set to random 1x-10x
self.spinout_target_rotation_speed = 0.0
self.spinout_original_max_speed = self.max_speed
self.spinout_collision_delay_timer = 0.0
self.spinout_collision_delay = random.uniform(0.5, 1.5)  # Random delay 0.5-1.5 seconds before explosion

# Visual rotation angle for spinout flame (separate from movement angle)
self.visual_rotation_angle = 0.0

# Load spinout flame image
try:
    self.spinout_flame_image = pygame.image.load(get_resource_path("spinout.gif"))
    self.spinout_flame_image = self.spinout_flame_image.convert_alpha()
    # Scale to 10% (95% smaller than original)
    original_size = self.spinout_flame_image.get_size()
    self.spinout_flame_image = pygame.transform.smoothscale(
        self.spinout_flame_image, 
        (int(original_size[0] * 0.1), int(original_size[1] * 0.1))
    )
except Exception as e:
    self.spinout_flame_image = None
"""

# Usage Notes:
# 1. The SpinoutParticle class provides specialized spark particles with physics
# 2. The three methods (trigger_spinout, update_spinout, draw_spinout) are part of the AdvancedUFO class
# 3. The add_spinout_spark method is part of the ExplosionSystem class
# 4. All methods include comprehensive error handling
# 5. The system supports both "firey" and "electric" spark types with different behaviors
# 6. Time dilation is properly handled throughout the system
# 7. The system includes both straight and spiral movement patterns for variety
